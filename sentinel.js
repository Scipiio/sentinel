

// ===========================================================================
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠇⠀⢻⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠲⣶⣶⣶⣶⣶⣶⣶⣾⡿⠀⠀⠈⣿⣶⣶⣶⣶⣶⣶⣶⡶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣾⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⣦⡄⠀⠀⠀⠀⠀⢠⣶⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⡿⠀⠀⠀⣀⠀⠀⠘⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⠄⠀⠀⠀⠀⠀⠀⢠⣿⠃⢀⣴⡾⠿⣷⣄⡀⢹⣷⠀⠀⠀⠀⠀⠀⠀⢦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⣀⣀⣴⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣾⠟⠋⠀⠀⠈⠙⢿⣶⣿⣇⠀⠀⠀⠀⠀⠀⠀⠙⢿⣶⣤⣄⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⣠⡾⢹⣿⠟⡅⠀⠀⠀⠀⠀⠀⠀⠀⣸⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠈⠛⢿⡄⠀⠀⠀⠀⠀⠀⠀⢨⡻⣿⡎⢿⣆⠀⠀⠀⠀
//    ⠀⠀⢠⢾⣿⠇⢟⣥⡾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠲⢤⣄⡀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⢻⣮⣿⠸⣿⡗⣄⠀⠀
//    ⠀⢠⡿⢸⣿⣴⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣦⣿⡇⣻⡆⠀
//    ⠀⣾⣷⢸⡿⣋⣴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣤⣄⣠⠀⠀⠀⠀⠈⢻⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢷⣌⢻⡇⣿⣿⠀
//    ⠀⢿⣿⢘⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠹⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣷⡄⣿⣿⢀
//    ⣧⠸⣿⣼⡿⣣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⣌⠻⣿⣿⠇⣼
//    ⣿⡆⢹⡟⣰⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⠟⠉⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⢹⣧⠹⡟⢠⣿
//    ⢻⣿⡄⢰⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠙⢿⣷⣦⡀⠀⠀⠀⠀⠀⣼⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠈⣿⣧⢠⣿⡟
//    ⡌⢿⣷⣾⡿⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⣦⡀⠀⠀⠀⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⣎⢹⣿⣾⡿⢁
//    ⣷⡌⠻⣿⡇⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⣦⣀⣼⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⢰⣿⠀⣿⠟⣠⣾
//    ⠘⣿⣦⡙⠃⣿⡇⣀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⡟⢿⣿⣶⣤⣄⣀⡀⠀⢀⣈⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⢀⢸⣿⠀⢋⣼⣿⠃
//     ⢸⢿⣿⣦⣿⣇⠸⣆⠀⠀⠀⠀⢀⣤⣾⡿⠉⠁⠀⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣀⠀⠀⠀⠀⠀⣰⡇⢸⣿⣴⣿⠟⡥⠀
//    ⠀⠀⢧⣍⠻⢿⣿⡀⣿⣇⠀⠀⢠⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠛⠛⠋⠉⠈⠻⣿⣿⡗⠀⠀⠀⣰⣿⠁⣾⡿⠛⣡⡾⠁⠀
//    ⠀⠀⠀⠻⣷⣦⣍⡳⢹⣿⡗⣦⡀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀⣠⢺⣿⡟⢈⣡⣴⣾⠟⠁⠀⠀
//    ⠀⠀⠀⠀⠈⢻⣿⣿⣶⣿⣿⡌⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⢃⣾⣿⣶⣿⠿⡟⠁⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠈⠳⣤⣍⣉⣛⣛⡊⠻⣿⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣿⠟⣡⣛⣉⣉⣭⣴⠞⠁⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠈⠙⢻⡿⠿⠿⠿⠿⠿⠛⣛⣩⣴⣶⡶⠞⣲⡶⢶⣶⡛⠿⣶⣶⣯⣉⡛⠛⠻⠿⠿⠿⠿⡟⠋⠁⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⠶⣦⣤⣶⣶⣿⣿⡿⠛⣡⣴⠟⠉⠀⠀⠈⠻⢷⣄⡙⠻⢿⣿⣷⣶⣶⣶⠶⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠀⠠⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠙⣿⡦⠀⠀⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// 
// 
// ===========================================================================
// 
// 


// ===========================================================================
//                             MODULES REQUIRED
// ===========================================================================

const { Client, 
		Intents, 
		ActionRowBuilder,
		EmbedBuilder,
		AttachmentBuilder,
		StringSelectMenuBuilder,
		StringSelectMenuOptionBuilder,
		ComponentType,
		GatewayIntentBits,
		ButtonBuilder,
		ButtonStyle,
		SlashCommandBuilder,  
		Partials, 
		ActivityType  } = require('discord.js');

const { REST } = require('@discordjs/rest');
const { Routes } = require('discord-api-types/v10');
const cluster = require('cluster');
const fs = require('fs');
const fetch = require('node-fetch');
const stringify = require('json-stringify-safe');
const schedule = require('node-schedule');
const chart = require('chart.js');

if(cluster.isMaster) {

	cluster.fork();
	cluster.on('disconnect', function(worker)
   {
       console.error('Crashed !');
       cluster.fork();
   });

} else {

// ===========================================================================
//                             GLOBALS VARIABLES
// ===========================================================================

const token = '  RAZARAZ ';
const clientId = '732934463163727932';;

let currentPresident = undefined
let currentMinister = undefined
let nextElection = new Date()
let candidate = []
let voteAck = []
let vote = []
let endVote = new Date()
let isVoting = false
let maintenance = false
let changeMinister = true
const logo  = new AttachmentBuilder('./.data/scicorp_logo.png');
let someoneVoting = false

//  TECH CONFIG TEST

const GLOBAL_operatorID = '160755858349883392'
const GLOBAL_guildID = '386614231853694997'
const GLOBAL_presidentRoleName = '690123903271698495'
const GLOBAL_ministreRoleName = '739765983845285888'
const GLOBAL_guardianRoleName = '739766033149329468'
const GLOBAL_channelAnnouncement = '472319778590031882'

//  TECH CONFIG PROD 
/*
const GLOBAL_operatorID = '160755858349883392'
const GLOBAL_guildID = '386614231853694997'
const GLOBAL_presidentRoleName = '690123903271698495'
const GLOBAL_ministreRoleName = '739765983845285888'
const GLOBAL_guardianRoleName = '739766033149329468'
const GLOBAL_channelAnnouncement = '472319778590031882'
*/

const membersProfile = [
	{
		'id':'160755858349883392',
		'name':'Scipio',
		'gender':'M',
		'profilePicUrl':''
	},
	{
		'id':'160755858349883392',
		'name':'Val',
		'gender':'M',
		'profilePicUrl':''
	},
]

const commands = [
    new SlashCommandBuilder()
        .setName('aide')
        .setDescription('Affiche l\'aide'),

    new SlashCommandBuilder()
        .setName('president')
        .setDescription('Afficher le ou la présidente actuelle'),

    new SlashCommandBuilder()
        .setName('ministre')
        .setDescription('Afficher le ou la ministre actuelle'),

    new SlashCommandBuilder()
        .setName('prochain')
        .setDescription('Date de la prochaine élection ou de la fin du scrutin'),

    new SlashCommandBuilder()
        .setName('postule')
        .setDescription('Postuler sa candidature')
        .addStringOption(option =>
            option.setName('programme')
                .setDescription('Ton programme (attention ! tu ne pourras pas l\'éditer)')
                .setRequired(true)
        ),

    new SlashCommandBuilder()
        .setName('candidats')
        .setDescription('Liste les candidat·es et leurs programmes'),

    new SlashCommandBuilder()
        .setName('vote')
        .setDescription('Voter, uniquement en période de vote'),

    new SlashCommandBuilder()
        .setName('changemin')
        .setDescription('PRESIDENT - Changer de ministre 1x par mandat')
        .addStringOption(option =>
            option.setName('ministre')
                .setDescription('Mentionne la personne que tu souhaites avoir comme nouveau ministre')
                .setRequired(true)
        ),

    new SlashCommandBuilder()
        .setName('remove')
        .setDescription('OPERATEUR - Supprime une candidature')
        .addStringOption(option =>
            option.setName('candidat')
                .setDescription('Mentionne le candidat à supprimer')
                .setRequired(true)
        ),

    new SlashCommandBuilder()
        .setName('forcevote')
        .setDescription('OPERATEUR - Force le scrutin'),

    new SlashCommandBuilder()
        .setName('forceelection')
        .setDescription('OPERATEUR - Force le début des votes'),

    new SlashCommandBuilder()
        .setName('toggle')
        .setDescription('OPERATEUR - Active le mode maintenance'),
];

const beginVoteSchedule = schedule.scheduleJob(nextElection, function(){
    let message
	if(candidate.length === 0){
		message = createEmbed("Début des votes","Les candidatures pour ce mois sont terminées.\nIl n'y a pas eu aucune candidature durant ce mois, le mandat de <@" + currentPresident.id + "> est donc prolongé jusqu'au mois prochain.")
		candidate = []
		changeMinister = true
	} else if (candidate.length === 1) {
		let genderP = getMemberGender(currentPresident.id)

		if(candidate[0].user.id === currentPresident.id){
			let embedTxtSolo = 'ERREUR SELECTION DU GENRE - TEXTE INVALIDE'
			embedTxtSolo = genderP === 'M' ? "Les candidatures pour ce mois sont terminées.\nSeul le président actuel a postulé, il est donc réélu pour ce mois." : false
			embedTxtSolo = genderP === 'F' ? "Les candidatures pour ce mois sont terminées.\nSeule la présidente actuelle a postulé, elle est donc réélue pour ce mois." : false

			message = createEmbed("Début des votes",embedTxtSolo)
			candidate = []
			changeMinister = true
		} else {
			let genderC = getMemberGender(candidate[0].user.id)
			let embedTxt1 = 'ERREUR SELECTION DU GENRE - TEXTE INVALIDE'
			embedTxt1 = genderC === 'M' ? "Un seul candidat a postulé pour être président, il sera donc en confrontation " : false
			embedTxt1 = genderC === 'F' ? "Une seule candidate a postulé pour être présidente, elle sera donc en confrontation " : false
			
			let embedTxt2 = 'ERREUR SELECTION DU GENRE - TEXTE INVALIDE'
			embedTxt2 = genderP === 'M' ? "avec l'actuel président <@" + currentPresident.id + ">" : false
			embedTxt2 = genderP === 'F' ? "avec l'actuelle présidente <@" + currentPresident.id + ">" : false
			
			message = createEmbed("Début des votes","Les élections mensuelles commencent.\n" + embedTxt1 + embedTxt2)
			let c = {
				id: currentPresident.id,
				username: currentPresident.username,
				tag: currentPresident.tag
			}
			addCandidate(c, "Candidature générée automatiquement pour ré-election")		
			isVoting = true
		}
	} else {
		message = createEmbed("Début des votes","Les élections mensuelles commencent.\nVous avez 24h pour voter. Pour cela, utilisez la commande /vote en privé. Les instructions de vote vous y seront expliquées.")
		isVoting = true						
	}

    announce(message)
	endVote = new Date();
	endVote.setDate(endVote.getDate() + 1);
	nextElection.setMonth(nextElection.getMonth() + 1);

	save();
});

const endVoteSchedule = schedule.scheduleJob(endVote, function(){
  	console.log('Vote Ended');
  	resolveVote();
	defineMinister();
	isVoting = false;
	changeMinister = true;
	candidate = [];
	voteAck = [];

	save();
});

let setStatus = () => {
	if(maintenance) {
	    client.user.setPresence({
	        status: 'idle', // 'online', 'idle', 'dnd', or 'invisible'
	        activities: [
	            {
	                name: 'En maintenance',
	                type: ActivityType.Playing, // 'PLAYING', 'WATCHING', 'LISTENING', 'STREAMING'
	            },
	        ],
	    });
	} else {
	    client.user.setPresence({
	        status: 'online', // 'online', 'idle', 'dnd', or 'invisible'
	        activities: [
	            {
	                name: 'le peuple',
	                type: ActivityType.Listening, // 'PLAYING', 'WATCHING', 'LISTENING', 'STREAMING'
	            },
	        ],
	    });
	}
}

let save = () => {
	console.log('----------------------------\nSauvegarde des variables\n')
	setTimeout(() => {
			let obj = {
			currentPresident: currentPresident,
			currentMinister: currentMinister,
			nextElection: nextElection,
			candidate: candidate,
			voteAck: voteAck,
			endVote: endVote,
			isVoting: isVoting,
			maintenance: maintenance,
			changeMinister: changeMinister
		}

		fs.writeFile('save-data.json', stringify(obj), 'utf8', () => {});
	}, 500)
}

let load = () => {
	fs.readFile('save-data.json', 'utf8', (err, data) => {
		if (err){
			console.log("Aucun fichier de sauvegarde trouvé, création d'un fichier vierge");
			save()
		} else {
			obj = JSON.parse(data); //now it an object
			currentPresident = obj.currentPresident
			currentMinister = obj.currentMinister
			nextElection = new Date(obj.nextElection)
			candidate = obj.candidate
			voteAck = obj.voteAck
			endVote = new Date(obj.endVote)
			isVoting = obj.isVoting
			maintenance = obj.maintenance
			changeMinister = obj.changeMinister
			console.log("Données restorées")
		}
	});
}

let announce = (embed) => {
	client.channels.cache.every((channel) => {
		if(channel.id === GLOBAL_channelAnnouncement){
			channel.send(embed)
			.catch(console.error)
		}
		return true
	})
}

let createEmbed = (titleText, contentText) => {

	let embed = new EmbedBuilder()
		.setColor(0xC21807)
		//.setThumbnail('attachment://spinning_earth.gif')
		.setAuthor({name: titleText})
		.setDescription(contentText)
		.setTimestamp()
		.setFooter({text: 'Propriété Sci//Corp', iconURL: 'attachment://scicorp_logo.png'});

	return { embeds: [embed], files: [logo] }
}

let addCandidate = (user, desc) => {
	candidate.push({
		'user': user,
		'desc': desc,
		'votes': 0
	})
}

let getMemberGender = (id) => {
	return membersProfile.filter(obj => {
  		return obj.id === id
	})
}

let checkIfAlreadyRegistered = (user) => {
	let code = false
	candidate.forEach((el) => {
		if(el.user.id == user.id){
			code = true
		}
	})
	return code
}

let countVote = (bulletin, userId) => {

	bulletin.forEach((vote, i) => {
		let iSearch = candidate.findIndex((obj) => obj.user.id === vote.user.id)
		candidate[iSearch].votes += candidate.length - i - 1
	})
	voteAck.push(userId)
}

let checkIfAlreadyVoted = (user) => {
	let code = false
	voteAck.forEach((el) => {
		if(el == user.id){
			code = true
		}
	})
	return code
}

let resolveVote = () => {
	if(voteAck.length > 0){
		let bestIndex = 0
		candidate.forEach((el, index) => {
			if(candidate[bestIndex].votes < el.votes) {
				bestIndex = index
			}
		})

		let winner = candidate[bestIndex].user
		let prog = candidate[bestIndex].desc
		let perc = candidate[bestIndex].votes
		let gender = getMemberGender(winner.id)
        
		let embedTxt = 'ERREUR SELECTION DU GENRE - TEXTE INVALIDE'
		embedTxt = gender === 'M' ? "Élection mensuelle terminée.\nNotre nouveau président est <@" + winner.id + ">, élu avec " + perc + " points.\nPour rappel, son programme :" : false
		embedTxt = gender === 'F' ? "Élection mensuelle terminée.\nNotre nouvelle présidente est <@" + winner.id + ">, élue avec " + perc + " points.\nPour rappel, son programme :" : false
		
		let em = createEmbed("Scrutin", embedTxt)
		announce(em)
		console.log(winner.username + ' a été élu président')

		if(guild.available){
			guild.members.cache.forEach((m) => {
				if (m.user.id === winner.id){
					console.log('Role président ajouté à ' + winner.username)
					m.roles.add(presidentRoleName)
				} else if (currentPresident !== undefined && m.user.id === currentPresident.id) {
					console.log('Role président supprimé à ' + currentPresident.username)
					m.roles.remove(presidentRoleName)
				}
			})
		}
		currentPresident = winner
		currentMinister = undefined
		save()
		return true
	} else {
		announce("Les élections mensuelles sont terminées.\nIl n'y a eu aucun votant (???), les élections sont donc repoussées au mois prochain.")
	}
}


const client = new Client({ 
	intents: [
		GatewayIntentBits.Guilds,
	    GatewayIntentBits.DirectMessages,
    	GatewayIntentBits.GuildMembers,                                    
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.GuildPresences],
    partials: [Partials.Channel]
});

client.once('ready', () => {
    console.log(`Connecté en tant que ${client.user.tag}`);
    
    //     Enregistre les commandes globales (pour un seul serveur)
    const rest = new REST({ version: '10' }).setToken(token);

    (async () => {
        try {
            console.log('Started refreshing application (/) commands.');

            await rest.put(
                Routes.applicationCommands(clientId),
                { body: commands },
            );

            console.log('Successfully reloaded application (/) commands.');
        } catch (error) {
            console.error(error);
        }
    })();

    // Définition du statut et de l'activité
    load();
    setStatus();
	maintenance ? console.log('MODE MAINTENANCE ACTIF') : false
});



// ===========================================================================
//                           SLASHES COMMANDS
// ===========================================================================

client.on('interactionCreate', async interaction => {

	if (!interaction.isChatInputCommand()) return;

	const { commandName } = interaction;
        
	let replyTxt = 'ERREUR SELECTION DU GENRE - TEXTE INVALIDE'

	if(maintenance && interaction.user.id !== GLOBAL_operatorID){
		await interaction.reply('Bot en maintenance, vous serez notifiez lors de la fin de la maintenance.')
	} else {
		switch (commandName) {
			case "president":
				maintenance ? console.log('president') : false

				if(currentPresident === undefined){
					await interaction.reply('Il n\'y a aucun président dans cette patrie')
				} else {
					let gender = getMemberGender(currentPresident.id)
					replyTxt = gender === 'M' ? 'L\'actuel président est ' : false
					replyTxt = gender === 'F' ? 'L\'actuelle présidente est ' : false

					await interaction.reply(replyTxt + currentPresident.tag)
				}
			break;

			case "ministre":
				maintenance ? console.log('ministre') : false

				if(currentMinister === undefined){
					await interaction.reply('Il n\'y a aucun ministre dans cette patrie')
				} else {
					let gender = getMemberGender(currentMinister.id)
					replyTxt = gender === 'M' ? 'L\'actuel ministre est ' : false
					replyTxt = gender === 'F' ? 'L\'actuelle ministre est ' : false

					await interaction.reply(replyTxt + currentPresident.tag)
				}
			break;

			case "changeMinistre":
				maintenance ? console.log('changeMinistre') : false

				if(interaction.user.id !== currentPresident.id){
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				} else {
					if(currentMinister === undefined){
						await interaction.reply('Il n\'y a aucun ministre dans cette patrie')
					} else {
						if(!changeMinister){
							await interaction.reply('Vous ne pouvez plus changer de ministre')
						} else {
							console.log("----------------------------\nChangement de ministre enclenché")

							await interaction.reply('Changement de ministre en cours.\nAprès cela, vous ne pourrez plus changer de ministre pour ce mois.')
							defineMinister()
							let member = guild.members.find((m) => m.id === currentMinister.id);
							member.roles.add("Ministre");
							member.roles.remove("Ministre");
							changeMinister = false
						}
					}
				}
			break;

			case "aide":
				maintenance ? console.log('aide') : false
				await interaction.reply(createEmbed('AIDE', helpTxt))
			break;

			case "prochain":
				maintenance ? console.log('prochain') : false

				if(isVoting){
					await interaction.reply('Il reste ' + countdown(null, endVote).toString() + ' avant la fin du vote')
				} else {
					await interaction.reply('Il reste ' + countdown(null, nextElection).toString() + ' avant les prochaines élections')
				}
			break;

			case "postule":
				if(isVoting){
					await interaction.reply('Les postulations sont actuellement fermées (vote en cours)')
				} else {
					if(!checkIfAlreadyRegistered(interaction.user)){
						const prog = interaction.options.getString('programme');
						let c = {
							id: interaction.user.id,
							username: interaction.user.username
						}
						addCandidate(c, prog)
						await interaction.reply('La candidature de <@' + interaction.user.id + '> a été prise en compte.')
						let em = createEmbed("Candidature de " + interaction.user.username, prog)
						announce(em)

						console.log('Candidature pour ' + interaction.user.username + ' acceptée')
						save()
					} else {
						await interaction.reply('Tu as déjà postulé·e pour les élections de ce mois')
					}
				}
			break;

			case "candidats":
				let response = ""
				if(candidate.length === 0){
					response = "Aucun·e candidat·e pour le moment !"
				} else {
					candidate.forEach((el, index) => {
						response += "\n" + index + " : " + el.user.username
					})
				}
				await interaction.reply(response)
			break;

			case "vote":
			// Check if command is in DM
				if(interaction.channel.type !== 1) {
					await interaction.reply('Les votes se déroulent en message privé.')
					interaction.user.send('Merci d\'utiliser la commande /vote ici.')
			// Check if currently voting
				} else if(!isVoting) {
					await interaction.reply('Aucun vote n\'est en cours')
			// Voting process
				} else if(checkIfAlreadyVoted(interaction.user)) {
					await interaction.reply('Vous avez déjà votez.')
				} else if(someoneVoting) {
					await interaction.reply('Quelqu\'un est déjà en train de voter. Merci de retenter plus tard (le bureau de vote est trés petit).')
				} else {
					someoneVoting = true
					let voteEnd = false
					let voteList = []
					voteList.push(...candidate)
					let voteListBulletin = []

					const voteSelectMenu = new StringSelectMenuBuilder()
					    .setCustomId(interaction.id)
						.setPlaceholder('Selectionnez un candidat...')
						.setMinValues(1)
						.setMaxValues(1)
						.addOptions(
							voteList.map((c, index) => 
						    	new StringSelectMenuOptionBuilder()
									.setLabel(c.user.username)
									.setValue("" + index)
							)
						)
					const actionRow = new ActionRowBuilder().addComponents(voteSelectMenu)
					const reply = await interaction.reply({content: "**Bulletin de vote**\nVous avez demarré une instance de vote.\nLes votes au sein de l'UDSS sont pondérés, ce qui veut dire que vous allez devoir trier l'ensemble des candidats dans l'ordre de préférence. Du plus souhaité au moins souhaité.\n\nSelectionnez le ou la candidate que vous préférez :", components: [actionRow]})

					const collector = reply.createMessageComponentCollector({
						filter: (i) => {
							i.deferUpdate();
							return i.user.id === interaction.user.id && i.customId === interaction.id},
						componentType: ComponentType.StringSelect, 
						time: 60_000,
					});

					collector.on('collect', (collectInteraction) => {

                        voteListBulletin.push(voteList[collectInteraction.values[0]])
						voteList.splice(collectInteraction.values[0],1)
						let updateTxt = "**Bulletin de vote**\n"
						voteListBulletin.forEach((c, i) => updateTxt += (i+1) + ". " + c.user.username + "\n")

						if(voteList.length === 0){

							const confirm = new ButtonBuilder()
								.setCustomId('confirm')
								.setLabel('Confirmer le vote')
								.setStyle(ButtonStyle.Success);

							const cancel = new ButtonBuilder()
								.setCustomId('cancel')
								.setLabel('Annuler')
								.setStyle(ButtonStyle.Danger);

							const actionRow = new ActionRowBuilder()
								.addComponents(cancel, confirm);

							interaction.editReply({content: updateTxt + "\n Confirmez l'ordre de préférence des candidats ?", components: [actionRow]})

							// Button Collect
							const collectButton = reply.createMessageComponentCollector({ 
								filter: (i) => {
									i.deferUpdate();
									return i.user.id === collectInteraction.user.id},
								componentType: ComponentType.Button, 
								time: 30_000 });

							collectButton.on('collect', collectButton => {

								cancel.setDisabled(true);
								confirm.setDisabled(true);
								const actionRow = new ActionRowBuilder()
									.addComponents(cancel, confirm);
								if (collectButton.customId === "cancel") {
									interaction.editReply({content: "Vote annulé.", components: [actionRow]});
									voteEnd = true;
								} else {
									countVote(voteListBulletin, interaction.user.id);
									interaction.editReply({content: "Votre vote a bien été comptabilisé.\n\nGloire à la patrie.", components: [actionRow]});
									console.log("Acquisition d'un vote")
									voteEnd = true;
									save();
								}
								someoneVoting = false
							});

							collectButton.on('end', collected => {
								if(!voteEnd) someoneVoting = false;
							});
						} else {
							const voteSelectMenu = new StringSelectMenuBuilder()
								.setCustomId(interaction.id)
								.setPlaceholder('Selectionnez un candidat...')
								.setMinValues(1)
								.setMaxValues(1)
								.addOptions(
									voteList.map((c, index) => 
										new StringSelectMenuOptionBuilder()
											.setLabel(c.user.username)
											.setValue("" + index)
									)
								)
							const actionRow = new ActionRowBuilder().addComponents(voteSelectMenu)

							interaction.editReply({content: updateTxt + "\n Selectionnez le prochain candidat :", components: [actionRow]})
						}
					})


					collector.on('end', collected => {
						console.log(`Collected ${collected.size} interactions.`);
						if(!voteEnd) someoneVoting = false;
					});
				}
			break;

			case "toggle":
				if (interaction.user.id === GLOBAL_operatorID){
					maintenance = !maintenance
					if(maintenance){
						console.log('MODE MAINTENANCE ACTIF');
						await interaction.reply("Passage en mode maintenance");
					} else {
						console.log('MODE MAINTENANCE INACTIF')
						await interaction.reply('Fin du mode maintenance')
					}
    				setStatus();
					save()
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			case 'remove':
				const candidat = interaction.options.getString('candidat');
				if (interaction.user.id === GLOBAL_operatorID){
					if(candidate[candidat]){
						console.log('Suppression du candidat ' + candidate[candidat].tag)
						let gender = getMemberGender(candidate[candidat].id)
						replyTxt = gender == 'M' ? "Le candidat " + candidate[candidat].tag + " a été retiré de l'élection" : false
						replyTxt = gender == 'F' ? "La candidate " + candidate[candidat].tag + " a été retirée de l'élection" : false
						await interaction.reply(replyTxt)
						candidate.splice(candidat, 1);
						save()
					} else {
						await interaction.reply("Candidat·e inconnu·e")
					}
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			case 'forcevote':
				if (interaction.user.id === operatorID){
					console.log('Scrutin enclenché manuellement')
					voteTimeout()
					defineMinister()
					
					isVoting = false
					candidate = []
					voteAck = []
					save()
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			case 'forceelection':
				if (interaction.user.id === operatorID){
					console.log('Elections enclenchés manuellement')
					nextElection = new Date()
					save()
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			default:
				await interaction.reply('Commande inconnue, veuillez reformuler')
		}
	}
});

client.login(token);

}
