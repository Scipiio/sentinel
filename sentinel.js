

// ===========================================================================
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠇⠀⢻⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠲⣶⣶⣶⣶⣶⣶⣶⣾⡿⠀⠀⠈⣿⣶⣶⣶⣶⣶⣶⣶⡶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣾⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⣦⡄⠀⠀⠀⠀⠀⢠⣶⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⡿⠀⠀⠀⣀⠀⠀⠘⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⠄⠀⠀⠀⠀⠀⠀⢠⣿⠃⢀⣴⡾⠿⣷⣄⡀⢹⣷⠀⠀⠀⠀⠀⠀⠀⢦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⣀⣀⣴⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣾⠟⠋⠀⠀⠈⠙⢿⣶⣿⣇⠀⠀⠀⠀⠀⠀⠀⠙⢿⣶⣤⣄⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⣠⡾⢹⣿⠟⡅⠀⠀⠀⠀⠀⠀⠀⠀⣸⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠈⠛⢿⡄⠀⠀⠀⠀⠀⠀⠀⢨⡻⣿⡎⢿⣆⠀⠀⠀⠀
//    ⠀⠀⢠⢾⣿⠇⢟⣥⡾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠲⢤⣄⡀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⢻⣮⣿⠸⣿⡗⣄⠀⠀
//    ⠀⢠⡿⢸⣿⣴⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣦⣿⡇⣻⡆⠀
//    ⠀⣾⣷⢸⡿⣋⣴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣤⣄⣠⠀⠀⠀⠀⠈⢻⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢷⣌⢻⡇⣿⣿⠀
//    ⠀⢿⣿⢘⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠹⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣷⡄⣿⣿⢀
//    ⣧⠸⣿⣼⡿⣣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⣌⠻⣿⣿⠇⣼
//    ⣿⡆⢹⡟⣰⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⠟⠉⠙⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⢹⣧⠹⡟⢠⣿
//    ⢻⣿⡄⢰⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠙⢿⣷⣦⡀⠀⠀⠀⠀⠀⣼⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠈⣿⣧⢠⣿⡟
//    ⡌⢿⣷⣾⡿⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⣦⡀⠀⠀⠀⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⣎⢹⣿⣾⡿⢁
//    ⣷⡌⠻⣿⡇⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⣦⣀⣼⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⢰⣿⠀⣿⠟⣠⣾
//    ⠘⣿⣦⡙⠃⣿⡇⣀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⡟⢿⣿⣶⣤⣄⣀⡀⠀⢀⣈⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⢀⢸⣿⠀⢋⣼⣿⠃
//     ⢸⢿⣿⣦⣿⣇⠸⣆⠀⠀⠀⠀⢀⣤⣾⡿⠉⠁⠀⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣀⠀⠀⠀⠀⠀⣰⡇⢸⣿⣴⣿⠟⡥⠀
//    ⠀⠀⢧⣍⠻⢿⣿⡀⣿⣇⠀⠀⢠⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠛⠛⠋⠉⠈⠻⣿⣿⡗⠀⠀⠀⣰⣿⠁⣾⡿⠛⣡⡾⠁⠀
//    ⠀⠀⠀⠻⣷⣦⣍⡳⢹⣿⡗⣦⡀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀⣠⢺⣿⡟⢈⣡⣴⣾⠟⠁⠀⠀
//    ⠀⠀⠀⠀⠈⢻⣿⣿⣶⣿⣿⡌⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⢃⣾⣿⣶⣿⠿⡟⠁⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠈⠳⣤⣍⣉⣛⣛⡊⠻⣿⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣿⠟⣡⣛⣉⣉⣭⣴⠞⠁⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠈⠙⢻⡿⠿⠿⠿⠿⠿⠛⣛⣩⣴⣶⡶⠞⣲⡶⢶⣶⡛⠿⣶⣶⣯⣉⡛⠛⠻⠿⠿⠿⠿⡟⠋⠁⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⠶⣦⣤⣶⣶⣿⣿⡿⠛⣡⣴⠟⠉⠀⠀⠈⠻⢷⣄⡙⠻⢿⣿⣷⣶⣶⣶⠶⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠀⠠⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠙⣿⡦⠀⠀⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// 
// 
// ===========================================================================
// 
// 


// ===========================================================================
//                             MODULES REQUIRED
// ===========================================================================

const { Client, 
		Intents, 
		ActionRowBuilder,
		EmbedBuilder,
		AttachmentBuilder,
		GatewayIntentBits,
		SlashCommandBuilder,  
		Partials, 
		ActivityType  } = require('discord.js');

const { REST } = require('@discordjs/rest');
const { Routes } = require('discord-api-types/v10');
const cluster = require('cluster');
const fs = require('fs');
const fetch = require('node-fetch');
const stringify = require('json-stringify-safe');
const schedule = require('node-schedule');
const chart = require('chart.js');

if(cluster.isMaster) {

	cluster.fork();
	cluster.on('disconnect', function(worker)
   {
       console.error('Crashed !');
       cluster.fork();
   });

} else {

// ===========================================================================
//                             GLOBALS VARIABLES
// ===========================================================================

const token = 'NzMyOTM0NDYzMTYzNzI3OTMy.Gqyskm.xnj0XDKUZAFGX4HdAHOg17XLzmq_ZPNUQsX6SY';
const clientId = '732934463163727932';;

let currentPresident = undefined
let currentMinister = undefined
let nextElection = new Date()
let candidate = []
let voteAck = []
let vote = []
let endVote = new Date()
let isVoting = false
let maintenance = false
let changeMinister = true

//  TECH CONFIG TEST

let GLOBAL_operatorID = '160755858349883392'
let GLOBAL_guildID = '386614231853694997'
let GLOBAL_presidentRoleName = '690123903271698495'
let GLOBAL_ministreRoleName = '739765983845285888'
let GLOBAL_guardianRoleName = '739766033149329468'
let GLOBAL_channelAnnouncement = '472319778590031882'

//  TECH CONFIG PROD 
/*
let GLOBAL_operatorID = '160755858349883392'
let GLOBAL_guildID = '307260668388573186'
let GLOBAL_presidentRoleName = 'Président'
let GLOBAL_ministreRoleName = 'Ministre'
let GLOBAL_guardianRoleName = 'Eternity Sentinel'
let GLOBAL_channelAnnouncement = '307260668388573186'
*/

const commands = [
    new SlashCommandBuilder()
        .setName('aide')
        .setDescription('Affiche l\'aide'),

    new SlashCommandBuilder()
        .setName('president')
        .setDescription('Afficher le ou la présidente actuelle'),

    new SlashCommandBuilder()
        .setName('ministre')
        .setDescription('Afficher le ou la ministre actuelle'),

    new SlashCommandBuilder()
        .setName('prochain')
        .setDescription('Date de la prochaine élection ou de la fin du scrutin'),

    new SlashCommandBuilder()
        .setName('postule')
        .setDescription('Postuler sa candidature')
        .addStringOption(option =>
            option.setName('programme')
                .setDescription('Ton programme (attention ! tu ne pourras pas l\'éditer)')
                .setRequired(true)
        ),

    new SlashCommandBuilder()
        .setName('candidats')
        .setDescription('Liste les candidat·es et leurs programmes'),

    new SlashCommandBuilder()
        .setName('vote')
        .setDescription('Voter, uniquement en période de vote'),

    new SlashCommandBuilder()
        .setName('changemin')
        .setDescription('PRESIDENT - Changer de ministre 1x par mandat'),

    new SlashCommandBuilder()
        .setName('remove')
        .setDescription('OPERATEUR - Supprime une candidature'),

    new SlashCommandBuilder()
        .setName('forcevote')
        .setDescription('OPERATEUR - Force le scrutin'),

    new SlashCommandBuilder()
        .setName('forceelection')
        .setDescription('OPERATEUR - Force le début des votes'),

    new SlashCommandBuilder()
        .setName('toggle')
        .setDescription('OPERATEUR - Active le mode maintenance'),
];

const beginVoteSchedule = schedule.scheduleJob(nextElection, function(){

	if(candidate.length === 0){
		announce("Les candidatures pour ce mois sont terminées !!!\nIl n'y a pas eu assez de candidature, les élections sont donc repoussées au mois prochain")
		candidate = []
		changeMinister = true
	} else if (candidate.length === 1) {
		if(candidate[0].user.id === currentPresident.id){
			announce("Les candidatures pour ce mois sont terminées !\nSeul le président actuel a postulé, il est donc réélu pour ce mois.")
			candidate = []
			changeMinister = true
		} else {
			announce("Les élections mensuelles commencent !\nUn seul candidat a postulé pour être président, il ou elle sera donc en confrontation avec l'actuel président")
			let c = {
				id: currentPresident.id,
				username: currentPresident.username,
				tag: currentPresident.tag
			}
			addCandidate(c, "Postulation générée automatiquement pour ré-election")		
			isVoting = true
		}
	} else {
		announce("Les élections mensuelles commencent !")
		isVoting = true						
	}

	endVote = new Date();
	endVote.setDate(endVote.getDate() + 1);
	nextElection.setMonth(nextElection.getMonth() + 1);

	save();
});

const endVoteSchedule = schedule.scheduleJob(endVote, function(){
  	console.log('Vote Ended');
  	resolveVote();
	defineMinister();
	isVoting = false;
	changeMinister = true;
	candidate = [];
	voteAck = [];

	save();
});

let setStatus = () => {
	if(maintenance) {
	    client.user.setPresence({
	        status: 'idle', // 'online', 'idle', 'dnd', or 'invisible'
	        activities: [
	            {
	                name: 'En maintenance',
	                type: ActivityType.Playing, // 'PLAYING', 'WATCHING', 'LISTENING', 'STREAMING'
	            },
	        ],
	    });
	} else {
	    client.user.setPresence({
	        status: 'online', // 'online', 'idle', 'dnd', or 'invisible'
	        activities: [
	            {
	                name: 'le peuple',
	                type: ActivityType.Listening, // 'PLAYING', 'WATCHING', 'LISTENING', 'STREAMING'
	            },
	        ],
	    });
	}
}

let save = () => {
	console.log('----------------------------\nSauvegarde des variables\n')
	setTimeout(() => {
			let obj = {
			currentPresident: currentPresident,
			currentMinister: currentMinister,
			nextElection: nextElection,
			candidate: candidate,
			voteAck: voteAck,
			endVote: endVote,
			isVoting: isVoting,
			maintenance: maintenance,
			changeMinister: changeMinister
		}

		fs.writeFile('save-data.json', stringify(obj), 'utf8', () => {});
	}, 500)
}

let load = () => {
	fs.readFile('save-data.json', 'utf8', (err, data) => {
		if (err){
			console.log("Aucun fichier de sauvegarde trouvé, création d'un fichier vierge");
			save()
		} else {
			obj = JSON.parse(data); //now it an object
			currentPresident = obj.currentPresident
			currentMinister = obj.currentMinister
			nextElection = new Date(obj.nextElection)
			candidate = obj.candidate
			voteAck = obj.voteAck
			endVote = new Date(obj.endVote)
			isVoting = obj.isVoting
			maintenance = obj.maintenance
			changeMinister = obj.changeMinister
			console.log("Données restorées")
		}
	});
}

let announce = (embed) => {
	client.channels.cache.every((channel) => {
		if(channel.id === GLOBAL_channelAnnouncement){
			channel.send(embed)
			.catch(console.error)
		}
		return true
	})
}

let createEmbed = (titleText, contentText) => {

	let logo  = new AttachmentBuilder('./.data/scicorp_logo.png');
	let embed = new EmbedBuilder()
		.setColor(0xC21807)
		.setThumbnail('attachment://spinning_earth.gif')
		.setAuthor({name: titleText})
		.setDescription(contentText)
		.setTimestamp()
		.setFooter({text: 'Ce message vous est présenté par Sci//Corp', iconURL: 'attachment://scicorp_logo.png'});

	return { embeds: [embed], files: [logo] }
}

let addCandidate = (user, desc) => {
	candidate.push({
		'user': user,
		'desc': desc,
		'votes': 0
	})
}

let checkIfAlreadyRegistered = (user) => {
	let code = false
	candidate.forEach((el) => {
		if(el.user.id == user.id){
			code = true
		}
	})
	return code
}

let checkIfAlreadyVoted = (user) => {
	let code = false
	voteAck.forEach((el) => {
		if(el == user.id){
			code = true
		}
	})
	return code
}

let resolveVote = () => {
	if(voteAck.length > 0){
		let bestIndex = 0
		candidate.forEach((el, index) => {
			if(candidate[bestIndex].votes < el.votes) {
				bestIndex = index
			}
		})

		let winner = candidate[bestIndex].user
		let prog = candidate[bestIndex].desc
		let perc = candidate[bestIndex].votes

		let em = createEmbed("Scrutin ", "Élection mensuelle terminée.\nNotre nouveau président est <@" + winner.id + ">, élu avec " + perc + " points.\nPour rappel, son programme :")
		announce(em)
		console.log(winner.username + ' a été élu président')

		if(guild.available){
			guild.members.cache.forEach((m) => {
				if (m.user.id === winner.id){
					console.log('Role président·e ajouté à ' + winner.username)
					m.roles.add(presidentRoleName)
				} else if (currentPresident !== undefined && m.user.id === currentPresident.id) {
					console.log('Role président·e supprimé à ' + currentPresident.username)
					m.roles.remove(presidentRoleName)
				}
			})
		}
		currentPresident = winner
		currentMinister = undefined
		save()
		return true
	} else {
		announce("Les élections mensuelles sont terminées !!!\nIl n'y a pas eu assez de votant, les élections sont donc repoussé au mois prochain !")
	}
}


const client = new Client({ intents: [
		GatewayIntentBits.Guilds,
	    GatewayIntentBits.DirectMessages,
    	GatewayIntentBits.GuildMembers,                                    
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.GuildPresences],
    'partials': [Partials.Channel]});

client.once('ready', () => {
    console.log(`Connecté en tant que ${client.user.tag}`);
    
    //     Enregistre les commandes globales (pour un seul serveur)
    const rest = new REST({ version: '10' }).setToken(token);

    (async () => {
        try {
            console.log('Started refreshing application (/) commands.');

            await rest.put(
                Routes.applicationGuildCommands(clientId, GLOBAL_guildID),
                { body: commands },
            );

            console.log('Successfully reloaded application (/) commands.');
        } catch (error) {
            console.error(error);
        }
    })();

    // Définition du statut et de l'activité
    setStatus();
	maintenance ? console.log('MODE MAINTENANCE ACTIF') : false

    load();
});



// ===========================================================================
//                           SLASHES COMMANDS
// ===========================================================================

client.on('interactionCreate', async interaction => {

	if (!interaction.isChatInputCommand()) return;

	const { commandName } = interaction;

	if(maintenance){
		if (interaction.user.id === GLOBAL_operatorID && commandName === "toggle"){
			maintenance = false
			console.log('MODE MAINTENANCE INACTIF')
			await interaction.reply('Fin du mode maintenance')
    		setStatus();
    		save();
		} else {
			await interaction.reply('Bizarre..............')
		}
	} else {
		switch (commandName) {
			case "president":
				maintenance ? console.log('president') : false

				if(currentPresident === undefined){
					await interaction.reply('Il n\'y a aucun président·e dans cette patrie')
				} else {
					await interaction.reply('L\'actuel·le président·e est : ' + currentPresident.tag)
				}
			break;

			case "ministre":
				maintenance ? console.log('ministre') : false

				if(currentMinister === undefined){
					await interaction.reply('Il n\'y a aucun ministre dans cette patrie')
				} else {
					await interaction.reply('L\'actuel·le ministre est : ' + currentMinister.tag)
				}
			break;

			case "changeMinistre":
				maintenance ? console.log('changeMinistre') : false

				if(interaction.user.id !== currentPresident.id){
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				} else {
					if(currentMinister === undefined){
						await interaction.reply('Il n\'y a aucun ministre dans cette patrie')
					} else {
						if(!changeMinister){
							await interaction.reply('Vous ne pouvez plus changer de ministre')
						} else {
							console.log("----------------------------\nChangement de ministre enclenché")

							await interaction.reply('Changement de ministre en cours.\nAprès cela, vous ne pourrez plus changer de ministre pour ce mois.')
							defineMinister()
							changeMinister = false
						}
					}
				}
			break;

			case "aide":
				maintenance ? console.log('aide') : false
				await interaction.reply(createEmbed('AIDE', helpTxt))
			break;

			case "prochain":
				maintenance ? console.log('prochain') : false

				if(isVoting){
					await interaction.reply('Il reste ' + countdown(null, endVote).toString() + ' avant la fin du vote')
				} else {
					await interaction.reply('Il reste ' + countdown(null, nextElection).toString() + ' avant les prochaines élections')
				}
			break;

			case "postule":
				if(isVoting){
					await interaction.reply('Les postulations sont actuellement fermées (vote en cours)')
				} else {
					if(!checkIfAlreadyRegistered(interaction.user)){
						const prog = interaction.options.getString('programme');
						let c = {
							id: interaction.user.id,
							username: interaction.user.username
						}
						addCandidate(c, prog)
						await interaction.reply('La candidature de <@' + interaction.user.id + '> a été prise en compte.')
						let em = createEmbed("Candidature de " + interaction.user.username, prog)
						announce(em)

						console.log('Candidature pour ' + interaction.user.username + ' acceptée')
						save()
					} else {
						await interaction.reply('Tu a déjà postulé·e pour les élections de ce mois')
					}
				}
			break;

			case "candidats":
				let response = ""
				if (args[0]){
					let el = candidate[args[0]]
					if(el){
						response += el.user.tag + " : ```\n" + el.desc + "\n```"
					} else {
						response += "Candidat inconnu·e"
					}
				} else {
					if(candidate.length === 0){
						response = "Aucun candidat pour le moment !"
					} else {
						if (isVoting) {	
							response += "Pour voter, donnez les numéros des candidat·es dans l'ordre de préférence.\nDans l'exemple '\\vote 2 0 1', 2 est le·a candidat·e préféré·e tandis que 1 est le·a moins préféré·e"								
							candidate.forEach((el, index) => {
							response += "\n" + index + " : " + el.user.tag
							})									
						} else {
							candidate.forEach((el, index) => {
							response += "\n" + index + " : " + el.user.tag
							})
						}
					}
				}
				await interaction.reply(response)
			break;

			case "vote":
				await interaction.reply('Aucun vote n\'est en cours')
				
			break;

			case "toggle":
				if (interaction.user.id === GLOBAL_operatorID){
					maintenance = true
					console.log('MODE MAINTENANCE ACTIF');

					await interaction.reply("Passage en mode maintenance");
    				setStatus();

					save()
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			case 'remove':
				if (interaction.user.id === operatorID){
					if (args[0]){
						let el = candidate[args[0]]
						if(el){
							candidate.splice(args[0], 1);
							console.log('Suppression du candidat ' + args[0])
							await interaction.reply("Le·a candidat·e " + args[0] + " a été retiré de l'élection")
							save()
						} else {
							await interaction.reply("Candidat·e inconnu·e")
						}
					}
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			case 'forceVoteTO':
				if (interaction.user.id === operatorID){
					console.log('Scrutin enclenché manuellement')
					voteTimeout()
					defineMinister()
					
					isVoting = false
					candidate = []
					voteAck = []
					save()
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			case 'forceElectionTO':
				if (interaction.user.id === operatorID){
					console.log('Elections enclenchés manuellement')
					nextElection = new Date()
					save()
				} else {
					await interaction.reply("Vous n'êtes pas autorisé·e à utiliser cette commande")
				}
			break;

			default:
				await interaction.reply('Commande inconnue, veuillez reformuler')
		}
	}
});

client.login(token);

}j
